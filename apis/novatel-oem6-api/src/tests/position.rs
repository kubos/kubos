//
// Copyright (C) 2018 Kubos Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

use super::*;
use messages::ReceiverStatusFlags;

#[test]
fn test_request_position_ontime() {
    let mut mock = MockStream::default();

    mock.write.set_input(vec![
        0xAA, 0x44, 0x12, 0x1C, 0x1, 0x0, 0x0, 0xC0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0xF1, 0x0, 0x0,
        0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xF0, 0x3F, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xB9, 0x54, 0x12, 0x6F,
    ]);

    mock.read.set_output(vec![
        0xAA, 0x44, 0x12, 0x1C, 0x1, 0x0, 0x80, 0x20, 0x6, 0x0, 0x0, 0x0, 0xFF, 0x78, 0xD1, 0xB,
        0x6, 0x67, 0xC9, 0x9, 0x0, 0x0, 0x0, 0x0, 0xFB, 0xFD, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x4F,
        0x4B, 0x10, 0x9D, 0x33, 0xB1,
    ]);

    let oem = mock_new!(mock);

    assert_eq!(oem.request_position(1.0, 0.0, false), Ok(()));
}

#[test]
fn test_request_position_once() {
    let mut mock = MockStream::default();

    mock.write.set_input(vec![
        0xAA, 0x44, 0x12, 0x1C, 0x1, 0x0, 0x0, 0xC0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0xF1, 0x0, 0x0,
        0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x54, 0x62, 0x3A, 0x96,
    ]);

    mock.read.set_output(vec![
        0xAA, 0x44, 0x12, 0x1C, 0x1, 0x0, 0x80, 0x20, 0x6, 0x0, 0x0, 0x0, 0xFF, 0x78, 0xD1, 0xB,
        0x6, 0x67, 0xC9, 0x9, 0x0, 0x0, 0x0, 0x0, 0xFB, 0xFD, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x4F,
        0x4B, 0x10, 0x9D, 0x33, 0xB1,
    ]);

    let oem = mock_new!(mock);

    assert_eq!(oem.request_position(0.0, 0.0, false), Ok(()));
}

#[test]
fn test_request_position_offset() {
    let mut mock = MockStream::default();

    mock.write.set_input(vec![
        0xAA, 0x44, 0x12, 0x1C, 0x1, 0x0, 0x0, 0xC0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0xF1, 0x0, 0x0,
        0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xF0, 0x3F, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0xE0, 0x3F, 0x0, 0x0, 0x0, 0x0, 0x6C, 0x60, 0x27, 0x5A,
    ]);

    mock.read.set_output(vec![
        0xAA, 0x44, 0x12, 0x1C, 0x1, 0x0, 0x80, 0x20, 0x6, 0x0, 0x0, 0x0, 0xFF, 0x78, 0xD1, 0xB,
        0x6, 0x67, 0xC9, 0x9, 0x0, 0x0, 0x0, 0x0, 0xFB, 0xFD, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x4F,
        0x4B, 0x10, 0x9D, 0x33, 0xB1,
    ]);

    let oem = mock_new!(mock);

    assert_eq!(oem.request_position(1.0, 0.5, false), Ok(()));
}

#[test]
fn test_request_position_hold() {
    let mut mock = MockStream::default();

    mock.write.set_input(vec![
        0xAA, 0x44, 0x12, 0x1C, 0x1, 0x0, 0x0, 0xC0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0xF1, 0x0, 0x0,
        0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xF0, 0x3F, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xDC, 0x33, 0xAE, 0xD7,
    ]);

    mock.read.set_output(vec![
        0xAA, 0x44, 0x12, 0x1C, 0x1, 0x0, 0x80, 0x20, 0x6, 0x0, 0x0, 0x0, 0xFF, 0x78, 0xD1, 0xB,
        0x6, 0x67, 0xC9, 0x9, 0x0, 0x0, 0x0, 0x0, 0xFB, 0xFD, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x4F,
        0x4B, 0x10, 0x9D, 0x33, 0xB1,
    ]);

    let oem = mock_new!(mock);

    assert_eq!(oem.request_position(1.0, 0.0, true), Ok(()));
}

#[test]
fn test_get_position() {
    let mut mock = MockStream::default();

    mock.read.set_output(vec![
        0xAA, 0x44, 0x12, 0x1C, 0xF1, 0x0, 0x0, 0x20, 0x70, 0x0, 0x0, 0x0, 0x7C, 0x78, 0xD1, 0xB,
        0xB8, 0x6A, 0xC9, 0x9, 0x0, 0x0, 0x48, 0x0, 0xC1, 0xFA, 0xFA, 0x33, 0x1, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x7A, 0x4C, 0xA9, 0xFD,
    ]);

    let oem = mock_new!(mock);

    let expected: Log = Log::BestXYZ(BestXYZLog {
        recv_status: ReceiverStatusFlags::CLOCK_MODEL_INVALID
            | ReceiverStatusFlags::POSITION_SOLUTION_INVALID,
        time_status: 120,
        week: 3025,
        ms: 164195000,
        pos_status: 1,
        pos_type: 0,
        position: [0.0, 0.0, 0.0],
        pos_deviation: [0.0, 0.0, 0.0],
        vel_status: 1,
        vel_type: 0,
        velocity: [0.0, 0.0, 0.0],
        vel_deviation: [0.0, 0.0, 0.0],
        station_id: "".to_owned(),
        vel_time_latency: 0.0,
        diff_age: 0.0,
        sol_age: 0.0,
        num_sats: 1,
        num_sat_vehicles: 0,
        num_gg_l1: 0,
        num_multi_sats: 0,
        ext_sol_stat: 0,
        gal_beidou_sig: 0,
        gps_glonass_sig: 0,
    });

    assert_eq!(oem.get_log().unwrap(), expected);
}
